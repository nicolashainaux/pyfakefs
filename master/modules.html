
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Public Modules and Classes &#8212; pyfakefs 4.7.dev0 documentation</title>
    <link rel="stylesheet" href="_static/pyfakefs.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Notes" href="api.html" />
    <link rel="prev" title="Automatically find and patch file functions and modules" href="autopatch.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="API Notes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="autopatch.html" title="Automatically find and patch file functions and modules"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyfakefs 4.7.dev0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="public-modules-and-classes">
<h1>Public Modules and Classes<a class="headerlink" href="#public-modules-and-classes" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only public classes and methods interesting to <code class="docutils literal notranslate"><span class="pre">pyfakefs</span></code>
users are shown. Methods that mimic the behavior of standard Python
functions and classes that are only needed internally are not listed.</p>
</div>
<div class="section" id="module-pyfakefs.fake_filesystem">
<span id="fake-filesystem-module"></span><h2>Fake filesystem module<a class="headerlink" href="#module-pyfakefs.fake_filesystem" title="Permalink to this headline">¶</a></h2>
<p>A fake filesystem implementation for unit testing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Includes:</th><td class="field-body"><ul class="first simple">
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFile" title="pyfakefs.fake_filesystem.FakeFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeFile</span></code></a>: Provides the appearance of a real file.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeDirectory" title="pyfakefs.fake_filesystem.FakeDirectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeDirectory</span></code></a>: Provides the appearance of a real directory.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFilesystem" title="pyfakefs.fake_filesystem.FakeFilesystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeFilesystem</span></code></a>: Provides the appearance of a real directory
hierarchy.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeOsModule" title="pyfakefs.fake_filesystem.FakeOsModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeOsModule</span></code></a>: Uses <a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFilesystem" title="pyfakefs.fake_filesystem.FakeFilesystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeFilesystem</span></code></a> to provide a
fake <code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code> module replacement.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeIoModule" title="pyfakefs.fake_filesystem.FakeIoModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeIoModule</span></code></a>: Uses <a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFilesystem" title="pyfakefs.fake_filesystem.FakeFilesystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeFilesystem</span></code></a> to provide a
fake <code class="docutils literal notranslate"><span class="pre">io</span></code> module replacement.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakePathModule" title="pyfakefs.fake_filesystem.FakePathModule"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakePathModule</span></code></a>:  Faked <code class="docutils literal notranslate"><span class="pre">os.path</span></code> module replacement.</li>
<li><a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFileOpen" title="pyfakefs.fake_filesystem.FakeFileOpen"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeFileOpen</span></code></a>:  Faked <code class="docutils literal notranslate"><span class="pre">file()</span></code> and <code class="docutils literal notranslate"><span class="pre">open()</span></code> function
replacements.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Usage:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyfakefs</span> <span class="k">import</span> <span class="n">fake_filesystem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filesystem</span> <span class="o">=</span> <span class="n">fake_filesystem</span><span class="o">.</span><span class="n">FakeFilesystem</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span> <span class="o">=</span> <span class="n">fake_filesystem</span><span class="o">.</span><span class="n">FakeOsModule</span><span class="p">(</span><span class="n">filesystem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pathname</span> <span class="o">=</span> <span class="s1">&#39;/a/new/dir/new-file&#39;</span>
</pre></div>
</div>
<p>Create a new file object, creating parent directory objects as needed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_file</span> <span class="o">=</span> <span class="n">filesystem</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
</pre></div>
</div>
<p>File objects can’t be overwritten:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">filesystem</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">assert</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">,</span> <span class="s1">&#39;unexpected errno: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span>
<span class="gp">... </span>  <span class="k">assert</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span> <span class="o">==</span> <span class="s1">&#39;File exists in the fake filesystem&#39;</span>
</pre></div>
</div>
<p>Remove a file object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filesystem</span><span class="o">.</span><span class="n">remove_object</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Create a new file object at the previous path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">beatles_file</span> <span class="o">=</span> <span class="n">filesystem</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="n">pathname</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">contents</span><span class="o">=</span><span class="s1">&#39;Dear Prudence</span><span class="se">\n</span><span class="s1">Won</span><span class="se">\&#39;</span><span class="s1">t you come out to play?</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Use the FakeFileOpen class to read fake file objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">file_module</span> <span class="o">=</span> <span class="n">fake_filesystem</span><span class="o">.</span><span class="n">FakeFileOpen</span><span class="p">(</span><span class="n">filesystem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_module</span><span class="p">(</span><span class="n">pathname</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">Dear Prudence</span>
<span class="go">Won&#39;t you come out to play?</span>
</pre></div>
</div>
<p>File objects cannot be treated like directory objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">os_module</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">assert</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOTDIR</span><span class="p">,</span> <span class="s1">&#39;unexpected errno: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span>
<span class="gp">... </span>  <span class="k">assert</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span> <span class="o">==</span> <span class="s1">&#39;Not a directory in the fake filesystem&#39;</span>
</pre></div>
</div>
<p>The FakeOsModule can list fake directory objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os_module</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span>
<span class="go">[&#39;new-file&#39;]</span>
</pre></div>
</div>
<p>The FakeOsModule also supports stat operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">stat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span><span class="o">.</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">os_module</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stat</span><span class="o">.</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">os_module</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">os_module</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">pathname</span><span class="p">))</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="function">
<dt id="pyfakefs.fake_filesystem.set_uid">
<code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">set_uid</code><span class="sig-paren">(</span><em>uid: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.set_uid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global user id. This is used as st_uid for new files
and to differentiate between a normal user and the root user (uid 0).
For the root user, some permission restrictions are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>uid</strong> – (int) the user ID of the user calling the file system functions.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pyfakefs.fake_filesystem.set_gid">
<code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">set_gid</code><span class="sig-paren">(</span><em>gid: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.set_gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global group id. This is only used to set st_gid for new files,
no permision checks are performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>gid</strong> – (int) the group ID of the user calling the file system functions.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="fake-filesystem-classes">
<h2>Fake filesystem classes<a class="headerlink" href="#fake-filesystem-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeFilesystem</code><span class="sig-paren">(</span><em>path_separator: str = '/'</em>, <em>total_size: int = None</em>, <em>patcher: Any = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the appearance of a real directory tree for unit testing.</p>
<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.path_separator">
<code class="descname">path_separator</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.path_separator" title="Permalink to this definition">¶</a></dt>
<dd><p>The path separator, corresponds to <cite>os.path.sep</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.alternative_path_separator">
<code class="descname">alternative_path_separator</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.alternative_path_separator" title="Permalink to this definition">¶</a></dt>
<dd><p>Corresponds to <cite>os.path.altsep</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.is_windows_fs">
<code class="descname">is_windows_fs</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.is_windows_fs" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> in a real or faked Windows file system.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.is_macos">
<code class="descname">is_macos</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.is_macos" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> under MacOS, or if we are faking it.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.is_case_sensitive">
<code class="descname">is_case_sensitive</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.is_case_sensitive" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>True</cite> if a case-sensitive file system is assumed.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.root">
<code class="descname">root</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.root" title="Permalink to this definition">¶</a></dt>
<dd><p>The root <a class="reference internal" href="#pyfakefs.fake_filesystem.FakeDirectory" title="pyfakefs.fake_filesystem.FakeDirectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">FakeDirectory</span></code></a> entry of the file system.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.umask">
<code class="descname">umask</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.umask" title="Permalink to this definition">¶</a></dt>
<dd><p>The umask used for newly created files, see <cite>os.umask</cite>.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.patcher">
<code class="descname">patcher</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.patcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the Patcher object if created from it. Allows access
to the patcher object if using the pytest fs fixture.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.patch_open_code">
<code class="descname">patch_open_code</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.patch_open_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how <cite>io.open_code</cite> will be patched;
patching can be on, off, or in automatic mode.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.shuffle_listdir_results">
<code class="descname">shuffle_listdir_results</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.shuffle_listdir_results" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>True</cite>, <cite>os.listdir</cite> will not sort the
results to match the real file system behavior.</p>
</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path_separator</strong> – optional substitute for os.path.sep</li>
<li><strong>total_size</strong> – if not None, the total size in bytes of the
root filesystem.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Example usage to use the same path separator under all systems:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filesystem</span> <span class="o">=</span> <span class="n">FakeFilesystem</span><span class="p">(</span><span class="n">path_separator</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.pause">
<code class="descname">pause</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause the patching of the file system modules until <cite>resume</cite> is
called. After that call, all file system calls are executed in the
real file system.
Calling pause() twice is silently ignored.
Only allowed if the file system object was created by a
Patcher object. This is also the case for the pytest <cite>fs</cite> fixture.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code> – if the file system was not created by a Patcher.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the patching of the file system modules if <cite>pause</cite> has
been called before. After that call, all file system calls are
executed in the fake file system.
Does nothing if patching is not paused.
:raises: <code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code> – if the file system has not been created by <cite>Patcher</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.add_mount_point">
<code class="descname">add_mount_point</code><span class="sig-paren">(</span><em>path: AnyStr</em>, <em>total_size: Optional[int] = None</em>, <em>can_exist: bool = False</em><span class="sig-paren">)</span> &#x2192; Dict[KT, VT]<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.add_mount_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new mount point for a filesystem device.
The mount point gets a new unique device number.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – The root path for the new mount path.</li>
<li><strong>total_size</strong> – The new total size of the added filesystem device
in bytes. Defaults to infinite size.</li>
<li><strong>can_exist</strong> – If True, no error is raised if the mount point
already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The newly created mount point dict.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if trying to mount an existing mount point again,
and <cite>can_exist</cite> is False.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.get_disk_usage">
<code class="descname">get_disk_usage</code><span class="sig-paren">(</span><em>path: AnyStr = None</em><span class="sig-paren">)</span> &#x2192; Tuple[int, int, int]<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.get_disk_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total, used and free disk space in bytes as named tuple,
or placeholder values simulating unlimited space if not set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This matches the return value of shutil.disk_usage().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – The disk space is returned for the file system device where
<cite>path</cite> resides.
Defaults to the root path (e.g. ‘/’ on Unix systems).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.set_disk_usage">
<code class="descname">set_disk_usage</code><span class="sig-paren">(</span><em>total_size: int</em>, <em>path: Optional[AnyStr] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.set_disk_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the total size of the file system, preserving the
used space.
Example usage: set the size of an auto-mounted Windows drive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>total_size</strong> – The new total size of the filesystem in bytes.</li>
<li><strong>path</strong> – The disk space is changed for the file system device where
<cite>path</cite> resides.
Defaults to the root path (e.g. ‘/’ on Unix systems).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the new space is smaller than the used size.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.get_object">
<code class="descname">get_object</code><span class="sig-paren">(</span><em>file_path: Union[AnyStr, os.PathLike], check_read_perm: bool = True</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeFile<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.get_object" title="Permalink to this definition">¶</a></dt>
<dd><p>Search for the specified filesystem object within the fake
filesystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – Specifies the target FakeFile object to retrieve.</li>
<li><strong>check_read_perm</strong> – If True, raises OSError if a parent directory
does not have read permission</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The FakeFile object corresponding to <cite>file_path</cite>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the object is not found.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.create_dir">
<code class="descname">create_dir</code><span class="sig-paren">(</span><em>directory_path: Union[AnyStr, os.PathLike], perm_bits: int = 511</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeDirectory<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.create_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <cite>directory_path</cite>, and all the parent directories.</p>
<p>Helper method to set up your test faster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>directory_path</strong> – The full directory path to create.</li>
<li><strong>perm_bits</strong> – The permission bits as set by <cite>chmod</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The newly created FakeDirectory object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the directory already exists.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.create_file">
<code class="descname">create_file</code><span class="sig-paren">(</span><em>file_path: Union[AnyStr, os.PathLike], st_mode: int = 33206, contents: Union[str, bytes] = '', st_size: Optional[int] = None, create_missing_dirs: bool = True, apply_umask: bool = False, encoding: Optional[str] = None, errors: Optional[str] = None, side_effect: Optional[Callable] = None</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeFile<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.create_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <cite>file_path</cite>, including all the parent directories along
the way.</p>
<p>This helper method can be used to set up tests more easily.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – The path to the file to create.</li>
<li><strong>st_mode</strong> – The stat constant representing the file type.</li>
<li><strong>contents</strong> – the contents of the file. If not given and st_size is
None, an empty file is assumed.</li>
<li><strong>st_size</strong> – file size; only valid if contents not given. If given,
the file is considered to be in “large file mode” and trying
to read from or write to the file will result in an exception.</li>
<li><strong>create_missing_dirs</strong> – If <cite>True</cite>, auto create missing directories.</li>
<li><strong>apply_umask</strong> – <cite>True</cite> if the current umask must be applied
on <cite>st_mode</cite>.</li>
<li><strong>encoding</strong> – If <cite>contents</cite> is a unicode string, the encoding used
for serialization.</li>
<li><strong>errors</strong> – The error mode used for encoding/decoding errors.</li>
<li><strong>side_effect</strong> – function handle that is executed when file is written,
must accept the file object as an argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The newly created FakeFile object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the file already exists.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the containing directory is required and missing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.add_real_file">
<code class="descname">add_real_file</code><span class="sig-paren">(</span><em>source_path: Union[AnyStr, os.PathLike], read_only: bool = True, target_path: Union[AnyStr, os.PathLike, None] = None</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeFile<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.add_real_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <cite>file_path</cite>, including all the parent directories along the
way, for an existing real file. The contents of the real file are read
only on demand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_path</strong> – Path to an existing file in the real file system</li>
<li><strong>read_only</strong> – If <cite>True</cite> (the default), writing to the fake file
raises an exception.  Otherwise, writing to the file changes
the fake file only.</li>
<li><strong>target_path</strong> – If given, the path of the target direction,
otherwise it is equal to <cite>source_path</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the newly created FakeFile object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the file does not exist in the real file system.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the file already exists in the fake file system.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On most systems, accessing the fake file’s contents may
update both the real and fake files’ <cite>atime</cite> (access time).
In this particular case, <cite>add_real_file()</cite> violates the rule
that <cite>pyfakefs</cite> must not modify the real file system.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.add_real_symlink">
<code class="descname">add_real_symlink</code><span class="sig-paren">(</span><em>source_path: Union[AnyStr, os.PathLike], target_path: Union[AnyStr, os.PathLike, None] = None</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeFile<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.add_real_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symlink at source_path (or target_path, if given).  It will
point to the same path as the symlink on the real filesystem.  Relative
symlinks will point relative to their new location.  Absolute symlinks
will point to the same, absolute path as on the real filesystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_path</strong> – The path to the existing symlink.</li>
<li><strong>target_path</strong> – If given, the name of the symlink in the fake
filesystem, otherwise, the same as <cite>source_path</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the newly created FakeFile object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the directory does not exist in the real file system.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the symlink could not be created
(see <a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFilesystem.create_file" title="pyfakefs.fake_filesystem.FakeFilesystem.create_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_file()</span></code></a>).</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the directory already exists in the fake file system.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.add_real_directory">
<code class="descname">add_real_directory</code><span class="sig-paren">(</span><em>source_path: Union[AnyStr, os.PathLike], read_only: bool = True, lazy_read: bool = True, target_path: Union[AnyStr, os.PathLike, None] = None</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeDirectory<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.add_real_directory" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a fake directory corresponding to the real directory at the
specified path.  Add entries in the fake directory corresponding to
the entries in the real directory.  Symlinks are supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_path</strong> – The path to the existing directory.</li>
<li><strong>read_only</strong> – If set, all files under the directory are treated as
read-only, e.g. a write access raises an exception;
otherwise, writing to the files changes the fake files only
as usually.</li>
<li><strong>lazy_read</strong> – <p>If set (default), directory contents are only read when
accessed, and only until the needed subdirectory level.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This means that the file system size is only updated
at the time the directory contents are read; set this to
<cite>False</cite> only if you are dependent on accurate file system
size in your test</p>
</div>
</li>
<li><strong>target_path</strong> – If given, the target directory, otherwise,
the target directory is the same as <cite>source_path</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the newly created FakeDirectory object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the directory does not exist in the real file system.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the directory already exists in the fake file system.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.add_real_paths">
<code class="descname">add_real_paths</code><span class="sig-paren">(</span><em>path_list: List[AnyStr], read_only: bool = True, lazy_dir_read: bool = True</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.add_real_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>This convenience method adds multiple files and/or directories from
the real file system to the fake file system. See <cite>add_real_file()</cite> and
<cite>add_real_directory()</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path_list</strong> – List of file and directory paths in the real file
system.</li>
<li><strong>read_only</strong> – If set, all files and files under under the directories
are treated as read-only, e.g. a write access raises an
exception; otherwise, writing to the files changes the fake
files only as usually.</li>
<li><strong>lazy_dir_read</strong> – Uses lazy reading of directory contents if set
(see <cite>add_real_directory</cite>)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if any of the files and directories in the list
does not exist in the real file system.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if any of the files and directories in the list
already exists in the fake file system.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFilesystem.create_symlink">
<code class="descname">create_symlink</code><span class="sig-paren">(</span><em>file_path: Union[AnyStr, os.PathLike], link_target: Union[AnyStr, os.PathLike], create_missing_dirs: bool = True</em><span class="sig-paren">)</span> &#x2192; pyfakefs.fake_filesystem.FakeFile<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFilesystem.create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the specified symlink, pointed at the specified link target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_path</strong> – path to the symlink to create</li>
<li><strong>link_target</strong> – the target of the symlink</li>
<li><strong>create_missing_dirs</strong> – If <cite>True</cite>, any missing parent directories of
file_path will be created</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The newly created FakeFile object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if the symlink could not be created
(see <a class="reference internal" href="#pyfakefs.fake_filesystem.FakeFilesystem.create_file" title="pyfakefs.fake_filesystem.FakeFilesystem.create_file"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_file()</span></code></a>).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeFile">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeFile</code><span class="sig-paren">(</span><em>name: AnyStr, st_mode: int = 33206, contents: Optional[AnyStr] = None, filesystem: Optional[FakeFilesystem] = None, encoding: Optional[str] = None, errors: Optional[str] = None, side_effect: Optional[Callable[[FakeFile], None]] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the appearance of a real file.</p>
<dl class="docutils">
<dt>Attributes currently faked out:</dt>
<dd><ul class="first last simple">
<li><cite>st_mode</cite>: user-specified, otherwise S_IFREG</li>
<li><cite>st_ctime</cite>: the time.time() timestamp of the file change time (updated
each time a file’s attributes is modified).</li>
<li><cite>st_atime</cite>: the time.time() timestamp when the file was last accessed.</li>
<li><cite>st_mtime</cite>: the time.time() timestamp when the file was last modified.</li>
<li><cite>st_size</cite>: the size of the file</li>
<li><cite>st_nlink</cite>: the number of hard links to the file</li>
<li><cite>st_ino</cite>: the inode number - a unique number identifying the file</li>
<li><cite>st_dev</cite>: a unique number identifying the (fake) file system device
the file belongs to</li>
<li><dl class="first docutils">
<dt><cite>st_uid</cite>: always set to USER_ID, which can be changed globally using</dt>
<dd><cite>set_uid</cite></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><cite>st_gid</cite>: always set to GROUP_ID, which can be changed globally using</dt>
<dd><cite>set_gid</cite></dd>
</dl>
</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The resolution for <cite>st_ctime</cite>, <cite>st_mtime</cite> and <cite>st_atime</cite> in the
real file system depends on the used file system (for example it is
only 1s for HFS+ and older Linux file systems, but much higher for
ext4 and NTFS). This is currently ignored by pyfakefs, which uses
the resolution of <cite>time.time()</cite>.</p>
<p class="last">Under Windows, <cite>st_atime</cite> is not updated for performance reasons by
default. pyfakefs never updates <cite>st_atime</cite> under Windows, assuming
the default setting.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – Name of the file/directory, without parent path information</li>
<li><strong>st_mode</strong> – The stat.S_IF* constant representing the file type (i.e.
stat.S_IFREG, stat.S_IFDIR), and the file permissions.
If no file type is set (e.g. permission flags only), a
regular file type is assumed.</li>
<li><strong>contents</strong> – The contents of the filesystem object; should be a string
or byte object for regular files, and a dict of other
FakeFile or FakeDirectory objects wih the file names as
keys for FakeDirectory objects</li>
<li><strong>filesystem</strong> – The fake filesystem where the file is created.</li>
<li><strong>encoding</strong> – If contents is a unicode string, the encoding used
for serialization.</li>
<li><strong>errors</strong> – The error mode used for encoding/decoding errors.</li>
<li><strong>side_effect</strong> – function handle that is executed when file is written,
must accept the file object as an argument.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFile.byte_contents">
<code class="descname">byte_contents</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.byte_contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contents as raw byte array.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFile.contents">
<code class="descname">contents</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contents as string with the original encoding.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFile.is_large_file">
<code class="descname">is_large_file</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.is_large_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <cite>True</cite> if this file was initialized with size
but no contents.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeFile.set_contents">
<code class="descname">set_contents</code><span class="sig-paren">(</span><em>contents: AnyStr</em>, <em>encoding: Optional[str] = None</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.set_contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the file contents and size and increases the modification time.
Also executes the side_effects if available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>contents</strong> – (str, bytes) new content of file.</li>
<li><strong>encoding</strong> – (str) the encoding to be used for writing the contents
if they are a unicode string.
If not given, the locale preferred encoding is used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if the contents have been changed.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if <cite>st_size</cite> is not a non-negative integer,
or if it exceeds the available file system space.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFile.size">
<code class="descname">size</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size in bytes of the file contents.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeFile.path">
<code class="descname">path</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFile.path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full path of the current object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeDirectory">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeDirectory</code><span class="sig-paren">(</span><em>name: str</em>, <em>perm_bits: int = 511</em>, <em>filesystem: Optional[FakeFilesystem] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides the appearance of a real directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – name of the file/directory, without parent path information</li>
<li><strong>perm_bits</strong> – permission bits. defaults to 0o777.</li>
<li><strong>filesystem</strong> – if set, the fake filesystem where the directory
is created</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeDirectory.ordered_dirs">
<code class="descname">ordered_dirs</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory.ordered_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of contained directory entry names ordered by
creation order.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeDirectory.get_entry">
<code class="descname">get_entry</code><span class="sig-paren">(</span><em>pathname_name: str</em><span class="sig-paren">)</span> &#x2192; Union[pyfakefs.fake_filesystem.FakeFile, pyfakefs.fake_filesystem.FakeDirectory]<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory.get_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the specified child file or directory entry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pathname_name</strong> – The basename of the child object to retrieve.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The fake file or directory object.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code> – if no child exists by the specified name.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem.FakeDirectory.remove_entry">
<code class="descname">remove_entry</code><span class="sig-paren">(</span><em>pathname_name: str</em>, <em>recursive: bool = True</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory.remove_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the specified child file or directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pathname_name</strong> – Basename of the child object to remove.</li>
<li><strong>recursive</strong> – If True (default), the entries in contained directories
are deleted first. Used to propagate removal errors
(e.g. permission problems) from contained entries.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code> – if no child exists by the specified name.</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code> – if user lacks permission to delete the file,
or (Windows only) the file is open.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeDirectory.size">
<code class="descname">size</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total size of all files contained in this directory tree.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem.FakeDirectory.contents">
<code class="descname">contents</code><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeDirectory.contents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the contents as string with the original encoding.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="unittest-module-classes">
<h2>Unittest module classes<a class="headerlink" href="#unittest-module-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem_unittest.</code><code class="descname">TestCaseMixin</code><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Test case mixin that automatically replaces file-system related
modules by fake implementations.</p>
<dl class="attribute">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.additional_skip_names">
<code class="descname">additional_skip_names</code><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.additional_skip_names" title="Permalink to this definition">¶</a></dt>
<dd><p>names of modules inside of which no module
replacement shall be performed, in addition to the names in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fake_filesystem_unittest.Patcher.SKIPNAMES</span></code>.
Instead of the module names, the modules themselves may be used.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.modules_to_reload">
<code class="descname">modules_to_reload</code><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.modules_to_reload" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of modules that need to be reloaded
to be patched dynamically; may be needed if the module
imports file system modules under an alias</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Reloading modules may have unwanted side effects.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.modules_to_patch">
<code class="descname">modules_to_patch</code><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.modules_to_patch" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary of fake modules mapped to the
fully qualified patched module names. Can be used to add patching
of modules not provided by <cite>pyfakefs</cite>.</p>
</dd></dl>

<p>If you specify some of these attributes here and you have DocTests,
consider also specifying the same arguments to <code class="xref py py-func docutils literal notranslate"><span class="pre">load_doctests()</span></code>.</p>
<p>Example usage in derived test classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">unittest</span> <span class="k">import</span> <span class="n">TestCase</span>
<span class="kn">from</span> <span class="nn">fake_filesystem_unittest</span> <span class="k">import</span> <span class="n">TestCaseMixin</span>

<span class="k">class</span> <span class="nc">MyTestCase</span><span class="p">(</span><span class="n">TestCase</span><span class="p">,</span> <span class="n">TestCaseMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodName</span><span class="o">=</span><span class="s1">&#39;runTest&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyTestCase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">methodName</span><span class="o">=</span><span class="n">methodName</span><span class="p">,</span>
            <span class="n">additional_skip_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;posixpath&#39;</span><span class="p">])</span>

<span class="kn">import</span> <span class="nn">sut</span>

<span class="k">class</span> <span class="nc">AnotherTestCase</span><span class="p">(</span><span class="n">TestCase</span><span class="p">,</span> <span class="n">TestCaseMixin</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodName</span><span class="o">=</span><span class="s1">&#39;runTest&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyTestCase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">methodName</span><span class="o">=</span><span class="n">methodName</span><span class="p">,</span> <span class="n">modules_to_reload</span><span class="o">=</span><span class="p">[</span><span class="n">sut</span><span class="p">])</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.setUpPyfakefs">
<code class="descname">setUpPyfakefs</code><span class="sig-paren">(</span><em>additional_skip_names: Optional[List[Union[str</em>, <em>module]]] = None</em>, <em>modules_to_reload: Optional[List[module]] = None</em>, <em>modules_to_patch: Optional[Dict[str</em>, <em>module]] = None</em>, <em>allow_root_user: bool = True</em>, <em>use_known_patches: bool = True</em>, <em>patch_open_code: pyfakefs.fake_filesystem.PatchMode = &lt;PatchMode.OFF: 1&gt;</em>, <em>patch_default_args: bool = False</em>, <em>use_cache: bool = True</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.setUpPyfakefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the file-related modules to the <code class="xref py py-class docutils literal notranslate"><span class="pre">pyfakefs</span></code> fake file
system instead of the real file system.  Also bind the fake <cite>open()</cite>
function.</p>
<p>Invoke this at the beginning of the <cite>setUp()</cite> method in your unit test
class.
For the arguments, see the <cite>TestCaseMixin</cite> attribute description.
If any of the arguments is not None, it overwrites the settings for
the current test case. Settings the arguments here may be a more
convenient way to adapt the setting than overwriting <cite>__init__()</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.pause">
<code class="descname">pause</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause the patching of the file system modules until <cite>resume</cite> is
called. After that call, all file system calls are executed in the
real file system.
Calling pause() twice is silently ignored.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.TestCaseMixin.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the patching of the file system modules if <cite>pause</cite> has
been called before. After that call, all file system calls are
executed in the fake file system.
Does nothing if patching is not paused.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem_unittest.TestCase">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem_unittest.</code><code class="descname">TestCase</code><span class="sig-paren">(</span><em>methodName: str = 'runTest'</em>, <em>additional_skip_names: Optional[List[Union[str</em>, <em>module]]] = None</em>, <em>modules_to_reload: Optional[List[module]] = None</em>, <em>modules_to_patch: Optional[Dict[str</em>, <em>module]] = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.TestCase" title="Permalink to this definition">¶</a></dt>
<dd><p>Test case class that automatically replaces file-system related
modules by fake implementations. Inherits <a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin" title="pyfakefs.fake_filesystem_unittest.TestCaseMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCaseMixin</span></code></a>.</p>
<p>The arguments are explained in <a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin" title="pyfakefs.fake_filesystem_unittest.TestCaseMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCaseMixin</span></code></a>.</p>
<p>Creates the test class instance and the patcher used to stub out
file system related modules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>methodName</strong> – The name of the test method (same as in
unittest.TestCase)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem_unittest.Patcher">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem_unittest.</code><code class="descname">Patcher</code><span class="sig-paren">(</span><em>additional_skip_names: Optional[List[Union[str</em>, <em>module]]] = None</em>, <em>modules_to_reload: Optional[List[module]] = None</em>, <em>modules_to_patch: Optional[Dict[str</em>, <em>module]] = None</em>, <em>allow_root_user: bool = True</em>, <em>use_known_patches: bool = True</em>, <em>patch_open_code: pyfakefs.fake_filesystem.PatchMode = &lt;PatchMode.OFF: 1&gt;</em>, <em>patch_default_args: bool = False</em>, <em>use_cache: bool = True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.Patcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a stub creator to bind and un-bind the file-related modules to
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyfakefs</span></code> fake modules.</p>
<p>The arguments are explained in <a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin" title="pyfakefs.fake_filesystem_unittest.TestCaseMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCaseMixin</span></code></a>.</p>
<p><a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.Patcher" title="pyfakefs.fake_filesystem_unittest.Patcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">Patcher</span></code></a> is used in <a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.TestCaseMixin" title="pyfakefs.fake_filesystem_unittest.TestCaseMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCaseMixin</span></code></a>.
<a class="reference internal" href="#pyfakefs.fake_filesystem_unittest.Patcher" title="pyfakefs.fake_filesystem_unittest.Patcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">Patcher</span></code></a> also works as a context manager for other tests:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Patcher</span><span class="p">():</span>
    <span class="n">doStuff</span><span class="p">()</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>additional_skip_names</strong> – names of modules inside of which no module
replacement shall be performed, in addition to the names in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">fake_filesystem_unittest.Patcher.SKIPNAMES</span></code>.
Instead of the module names, the modules themselves
may be used.</li>
<li><strong>modules_to_reload</strong> – <p>A list of modules that need to be reloaded
to be patched dynamically; may be needed if the module
imports file system modules under an alias</p>
<div class="admonition caution">
<p class="first admonition-title">Caution</p>
<p class="last">Reloading modules may have unwanted side effects.</p>
</div>
</li>
<li><strong>modules_to_patch</strong> – A dictionary of fake modules mapped to the
fully qualified patched module names. Can be used to add
patching of modules not provided by <cite>pyfakefs</cite>.</li>
<li><strong>allow_root_user</strong> – If True (default), if the test is run as root
user, the user in the fake file system is also considered a
root user, otherwise it is always considered a regular user.</li>
<li><strong>use_known_patches</strong> – If True (the default), some patches for commonly
used packages are applied which make them usable with pyfakefs.</li>
<li><strong>patch_open_code</strong> – If True, <cite>io.open_code</cite> is patched. The default
is not to patch it, as it mostly is used to load compiled
modules that are not in the fake file system.</li>
<li><strong>patch_default_args</strong> – If True, default arguments are checked for
file system functions, which are patched. This check is
expansive, so it is off by default.</li>
<li><strong>use_cache</strong> – If True (default), patched and non-patched modules are
cached between tests for performance reasons. As this is a new
feature, this argument allows to turn it off in case it
causes any problems.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.Patcher.setUp">
<code class="descname">setUp</code><span class="sig-paren">(</span><em>doctester: Any = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.Patcher.setUp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bind the file-related modules to the <code class="xref py py-mod docutils literal notranslate"><span class="pre">pyfakefs</span></code> fake
modules real ones.  Also bind the fake <cite>file()</cite> and <cite>open()</cite> functions.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.Patcher.tearDown">
<code class="descname">tearDown</code><span class="sig-paren">(</span><em>doctester: Any = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.Patcher.tearDown" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the fake filesystem bindings created by <cite>setUp()</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.Patcher.pause">
<code class="descname">pause</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.Patcher.pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Pause the patching of the file system modules until <cite>resume</cite> is
called. After that call, all file system calls are executed in the
real file system.
Calling pause() twice is silently ignored.</p>
</dd></dl>

<dl class="method">
<dt id="pyfakefs.fake_filesystem_unittest.Patcher.resume">
<code class="descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.Patcher.resume" title="Permalink to this definition">¶</a></dt>
<dd><p>Resume the patching of the file system modules if <cite>pause</cite> has
been called before. After that call, all file system calls are
executed in the fake file system.
Does nothing if patching is not paused.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-pyfakefs.fake_filesystem_unittest"></span><p>This module provides a base class derived from <cite>unittest.TestClass</cite>
for unit tests using the <code class="xref py py-class docutils literal notranslate"><span class="pre">pyfakefs</span></code> module.</p>
<p><cite>fake_filesystem_unittest.TestCase</cite> searches <cite>sys.modules</cite> for modules
that import the <cite>os</cite>, <cite>io</cite>, <cite>path</cite> <cite>shutil</cite>, and <cite>pathlib</cite> modules.</p>
<p>The <cite>setUpPyfakefs()</cite> method binds these modules to the corresponding fake
modules from <cite>pyfakefs</cite>.  Further, the <cite>open()</cite> built-in is bound to a fake
<cite>open()</cite>.</p>
<p>It is expected that <cite>setUpPyfakefs()</cite> be invoked at the beginning of the
derived class’ <cite>setUp()</cite> method.  There is no need to add anything to the
derived class’ <cite>tearDown()</cite> method.</p>
<p>During the test, everything uses the fake file system and modules.  This means
that even in your test fixture, familiar functions like <cite>open()</cite> and
<cite>os.makedirs()</cite> manipulate the fake file system.</p>
<p>Existing unit tests that use the real file system can be retrofitted to use
pyfakefs by simply changing their base class from <cite>:py:class`unittest.TestCase</cite>
to <cite>:py:class`pyfakefs.fake_filesystem_unittest.TestCase</cite>.</p>
<dl class="function">
<dt id="pyfakefs.fake_filesystem_unittest.patchfs">
<code class="descclassname">pyfakefs.fake_filesystem_unittest.</code><code class="descname">patchfs</code><span class="sig-paren">(</span><em>_func: Callable = None</em>, <em>*</em>, <em>additional_skip_names: Optional[List[Union[str</em>, <em>module]]] = None</em>, <em>modules_to_reload: Optional[List[module]] = None</em>, <em>modules_to_patch: Optional[Dict[str</em>, <em>module]] = None</em>, <em>allow_root_user: bool = True</em>, <em>use_known_patches: bool = True</em>, <em>patch_open_code: pyfakefs.fake_filesystem.PatchMode = &lt;PatchMode.OFF: 1&gt;</em>, <em>patch_default_args: bool = False</em>, <em>use_cache: bool = True</em><span class="sig-paren">)</span> &#x2192; Callable<a class="headerlink" href="#pyfakefs.fake_filesystem_unittest.patchfs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience decorator to use patcher with additional parameters in a
test function.</p>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@patchfs</span>
<span class="k">def</span> <span class="nf">test_my_function</span><span class="p">(</span><span class="n">fake_fs</span><span class="p">):</span>
    <span class="n">fake_fs</span><span class="o">.</span><span class="n">create_file</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>

<span class="nd">@patchfs</span><span class="p">(</span><span class="n">allow_root_user</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_with_patcher_args</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="s1">&#39;foo/bar&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="faked-module-classes">
<h2>Faked module classes<a class="headerlink" href="#faked-module-classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeOsModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeOsModule</code><span class="sig-paren">(</span><em>filesystem: pyfakefs.fake_filesystem.FakeFilesystem</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeOsModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses FakeFilesystem to provide a fake os module replacement.</p>
<p>Do not create os.path separately from os, as there is a necessary circular
dependency between os and os.path to replicate the behavior of the standard
Python modules.  What you want to do is to just let FakeOsModule take care
of <cite>os.path</cite> setup itself.</p>
<p># You always want to do this.
filesystem = fake_filesystem.FakeFilesystem()
my_os_module = fake_filesystem.FakeOsModule(filesystem)</p>
<p>Also exposes self.path (to fake os.path).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filesystem</strong> – FakeFilesystem used to provide file system information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakePathModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakePathModule</code><span class="sig-paren">(</span><em>filesystem: pyfakefs.fake_filesystem.FakeFilesystem</em>, <em>os_module: pyfakefs.fake_filesystem.FakeOsModule</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakePathModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Faked os.path module replacement.</p>
<p>FakePathModule should <em>only</em> be instantiated by FakeOsModule.  See the
FakeOsModule docstring for details.</p>
<p>Init.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filesystem</strong> – FakeFilesystem used to provide file system information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeFileOpen">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeFileOpen</code><span class="sig-paren">(</span><em>filesystem: pyfakefs.fake_filesystem.FakeFilesystem</em>, <em>delete_on_close: bool = False</em>, <em>raw_io: bool = False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeFileOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Faked <cite>file()</cite> and <cite>open()</cite> function replacements.</p>
<p>Returns FakeFile objects in a FakeFilesystem in place of the <cite>file()</cite>
or <cite>open()</cite> function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filesystem</strong> – FakeFilesystem used to provide file system information</li>
<li><strong>delete_on_close</strong> – optional boolean, deletes file on close()</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem.FakeIoModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem.</code><code class="descname">FakeIoModule</code><span class="sig-paren">(</span><em>filesystem: pyfakefs.fake_filesystem.FakeFilesystem</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem.FakeIoModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses FakeFilesystem to provide a fake io module replacement.</p>
<p>You need a fake_filesystem to use this:
filesystem = fake_filesystem.FakeFilesystem()
my_io_module = fake_filesystem.FakeIoModule(filesystem)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filesystem</strong> – FakeFilesystem used to provide file system information.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_filesystem_shutil.FakeShutilModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_filesystem_shutil.</code><code class="descname">FakeShutilModule</code><span class="sig-paren">(</span><em>filesystem</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_filesystem_shutil.FakeShutilModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a FakeFilesystem to provide a fake replacement for shutil module.</p>
<p>Construct fake shutil module using the fake filesystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filesystem</strong> – FakeFilesystem used to provide file system information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_pathlib.FakePathlibModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_pathlib.</code><code class="descname">FakePathlibModule</code><span class="sig-paren">(</span><em>filesystem</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_pathlib.FakePathlibModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses FakeFilesystem to provide a fake pathlib module replacement.
Can be used to replace both the standard <cite>pathlib</cite> module and the
<cite>pathlib2</cite> package available on PyPi.</p>
<p>You need a fake_filesystem to use this:
<cite>filesystem = fake_filesystem.FakeFilesystem()</cite>
<cite>fake_pathlib_module = fake_filesystem.FakePathlibModule(filesystem)</cite></p>
<p>Initializes the module with the given filesystem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filesystem</strong> – FakeFilesystem used to provide file system information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pyfakefs.fake_scandir.FakeScanDirModule">
<em class="property">class </em><code class="descclassname">pyfakefs.fake_scandir.</code><code class="descname">FakeScanDirModule</code><span class="sig-paren">(</span><em>filesystem</em><span class="sig-paren">)</span><a class="headerlink" href="#pyfakefs.fake_scandir.FakeScanDirModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses FakeFilesystem to provide a fake <cite>scandir</cite> module replacement.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">scandir</span></code> function is a part of the standard <code class="docutils literal notranslate"><span class="pre">os</span></code> module
since Python 3.5. This class handles the separate <code class="docutils literal notranslate"><span class="pre">scandir</span></code> module
that is available on pypi.</p>
</div>
<p>You need a fake_filesystem to use this:
<cite>filesystem = fake_filesystem.FakeFilesystem()</cite>
<cite>fake_scandir_module = fake_filesystem.FakeScanDirModule(filesystem)</cite></p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Public Modules and Classes</a><ul>
<li><a class="reference internal" href="#module-pyfakefs.fake_filesystem">Fake filesystem module</a></li>
<li><a class="reference internal" href="#fake-filesystem-classes">Fake filesystem classes</a></li>
<li><a class="reference internal" href="#unittest-module-classes">Unittest module classes</a></li>
<li><a class="reference internal" href="#faked-module-classes">Faked module classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="autopatch.html"
                        title="previous chapter">Automatically find and patch file functions and modules</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api.html"
                        title="next chapter">API Notes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modules.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="API Notes"
             >next</a> |</li>
        <li class="right" >
          <a href="autopatch.html" title="Automatically find and patch file functions and modules"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pyfakefs 4.7.dev0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009 Google Inc. All Rights Reserved.
© Copyright 2014 Altera Corporation. All Rights Reserved.
© Copyright 2014-2021 John McGehee.
      Last updated on Aug 25, 2022.
    </div>
  </body>
</html>